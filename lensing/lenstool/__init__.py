'''
load_bayes.py
Author: Traci Johnson
Update: 5/15/2017
    Added potential to the list of files that can be generated by writeInputFiles()
    Corrected bug which did not update the names of the files generated by lenstool.
    Added option to set the random seed number.
    Added filemap input to writeInputFiles() which maps the output file name with the
      line in the bayes.dat file (starting an index of 0).
Update: 1/27/2017
    Added 'readkpc' keyword to read in core_radius_kpc and cut_radius_kpc from bestopt.par
    file generated using writeBest()
Update: 1/12/2017
    Added writeBest(), creates bestopt.par file from the bayes.dat
'''

import numpy as np
import os

class Bayes:
    def __init__(self,bayesfile='bayes.dat'):
        f = open(bayesfile,'r')
        lines = f.readlines()
        f.close()

        self.parameters = []

        # start from top of file and create list of parameters
        i = 0
        while lines[i][0] == '#':
            self.parameters.append(lines[i].rstrip()[1:])
            i = i + 1

        nparams = len(self.parameters)
        nmodels = len(lines)-nparams
        self.models = np.zeros((nmodels, nparams))

        for j in range(i,i+nmodels):
            self.models[j-nparams,:] = np.array(lines[j].rsplit(),dtype = np.float)           

        for i in range(len(self.parameters)):
            if self.parameters[i]=='Chi2':
                chi2col = i

        self.minchi2 = np.amin(self.models[:,chi2col])
        self.bestmodel = np.where(self.models[:,chi2col] == self.minchi2)
        self.nmodels = nmodels


    def writeInputFiles(self,bestfile='best.par',nfiles=1,files=['kappa','gamma'],filemap='map.out',
        filename=['kappa','gamma'],z=[2],imsize=[500],new_champ=False,verbose=False,randomseed=0,
        nsamples=100,inputdir='input_files',nthreads=25,lenstool='lenstool',readkpc=False):
        f = open(bestfile,'r')
        lines = f.readlines()
        f.close()

        freeParams = np.zeros((2,len(self.parameters))).astype('str')
        for i in range(len(self.parameters)):
            parsep = self.parameters[i].rsplit()
            if len(parsep) < 2: continue
            if parsep[2] == "x": variable = "x_centre"
            if parsep[2] == "y": variable = "y_centre"
            if parsep[2] == "emass": variable = "ellipticite"
            if parsep[2] == "theta": variable = "angle_pos"
            if parsep[2] == "rc": variable = "core_radius"
            if parsep[2] == "sigma": variable = "v_disp"
            if parsep[2] == "rcut": variable = "cut_radius"
            if parsep[0] == "Redshift": variable = " ".join(parsep[2:])
            freeParams[0,i] = parsep[0]
            freeParams[1,i] = variable

        if len(z) == 1:
            z = np.ones(len(files))*z
        if len(imsize) == 1:
            imsize = np.ones(len(files))*imsize

        ff = open(inputdir+'/'+filemap,'w')
        if randomseed > 0:
           np.random.seed(randomseed)
           ff.write('# generated with random seed = {0}\n'.format(str(randomseed)))
        indices = np.random.choice(np.arange(self.nmodels),size=nsamples,replace=False).astype(int)

        com = open(inputdir+'/commands','w')
        for t in range(nthreads):
            com.write('taskset -c {0} ./commands{0} & \n'.format(str(t)))

        for n in range(nsamples):
            m = int(indices[n])
            fnm = str(n).zfill(int(np.log10(nsamples)))
            ff.write('{0}\t{1}\n'.format(fnm,int(indices[n])))
            inputfile = inputdir+'/input{0}.par'.format(fnm)
            f = open(inputfile,'w')

            if n % (nsamples/nthreads) == 0:
                com.close()
                com = open(inputdir+'/commands'+str(n // (nsamples/nthreads)),'w')
            com.write(lenstool+' input{0}.par -n\n'.format(fnm))

            i=0
            while i < len(lines):
                ls = lines[i].rsplit()
                if len(ls) == 0:
                    i+=1
                    continue
                if ls[0] == 'runmode':
                    while ls[0] != 'end':
                        f.write(lines[i])
                        i+=1
                        ls = lines[i].rsplit()
                        if ls[0] == 'verbose' and not verbose:
                            lines[i] = '    verbose  0\n'
                    ### this is where you add the lines for writing the outputs
                    for k in range(len(files)):
                        if files[k] == 'kappa':
                            f.write('    mass 1 {0:d} {1:0.3f} {2}{3}.fits\n'.format(int(imsize[k]),z[k],filename[k],fnm))
                        if files[k] == 'mass':
                            f.write('    mass 3 {0:d} 1.000 {1}{2}.fits\n'.format(int(imsize[k]),filename[k],fnm))
                        if files[k] == 'gamma':
                            f.write('    shear 1 {0:d} {1:0.3f} {2}{3}.fits\n'.format(int(imsize[k]),z[k],filename[k],fnm))
                        if files[k] == 'magnific':
                            f.write('    ampli 1 {0:d} {1:0.3f} {2}{3}.fits\n'.format(int(imsize[k]),z[k],filename[k],fnm))
                        if files[k] == 'deflect':
                            f.write('    dpl 1 {0:d} {1:0.3f} {2}x{3}.fits {2}y{3}.fits\n'.format(int(imsize[k]),z[k],filename[k],fnm))
                        if files[k] == 'potential':
                            f.write('    poten 1 {0:d} {1:0.3f} {2}{3}.fits\n'.format(int(imsize[k]),z[k],filename[k],fnm))
                    f.write(lines[i])

                ## parts of the file that can be directly copied
                if ls[0] == 'grille':
                    while ls[0] != 'end':
                        f.write(lines[i])
                        i+=1
                        ls = lines[i].rsplit()
                    f.write(lines[i])
                if ls[0] == 'source':
                    while ls[0] != 'end':
                        f.write(lines[i])
                        i+=1
                        ls = lines[i].rsplit()
                    f.write(lines[i])
                if ls[0] == 'image':
                    while ls[0] != 'end':
                        f.write(lines[i])
                        i+=1
                        ls = lines[i].rsplit()
                    f.write(lines[i])
                if ls[0] == 'cosmologie':
                    while ls[0] != 'end':
                        f.write(lines[i])
                        i+=1
                        ls = lines[i].rsplit()
                    f.write(lines[i])
                if ls[0] == 'potfile':
                    while ls[0] != 'end':
                        f.write(lines[i])
                        i+=1
                        ls = lines[i].rsplit()
                    f.write(lines[i])
                if ls[0] == 'champ':
                    f.write(lines[i])
                    i+=1
                    ls = lines[i].rsplit()
                    if not new_champ:
                        while ls[0] != 'end':
                            f.write(lines[i])
                            i+=1
                            ls = lines[i].rsplit()
                        f.write(lines[i])
                    else:
                        while ls[0] != 'end':
                            i+=1
                            ls = lines[i].rsplit()
                        f.write('    xmin    {0:0.3f}\n'.format(new_champ[0]))
                        f.write('    xmax    {0:0.3f}\n'.format(new_champ[1]))
                        f.write('    ymin    {0:0.3f}\n'.format(new_champ[2]))
                        f.write('    ymax    {0:0.3f}\n'.format(new_champ[3]))
                        f.write(lines[i])
                if ls[0] == 'fini':
                    f.write(lines[i])
                

                ### add free parameters to the potential blocks
                if ls[0] == 'potentiel':
                    f.write(lines[i])
                    potname = ls[1]
                    while ls[0] != 'end':
                        i+=1
                        ls = lines[i].rsplit()
                        paramtype = ls[0]
                        if readkpc and paramtype == "cut_radius_kpc": paramtype = "cut_radius"
                        if readkpc and paramtype == "core_radius_kpc": paramtype = "core_radius"
                        if paramtype == "cut_radius_kpc" or paramtype == "core_radius_kpc" or paramtype == 'mag': continue
                        paramIndex = np.all([freeParams[0,:] == potname,freeParams[1,:] == paramtype],axis=0)
                        if np.sum(paramIndex) == 1:
                            model = self.models[m,:].flatten()
                            f.write('    {0}    {1:0.3f}\n'.format(paramtype,model[paramIndex][0]))
                        else:
                            f.write(lines[i])
                i+=1

            f.close()
        com.close()
        ff.close()

        os.system('chmod u+x '+inputdir+'/commands*')

    def writeBest(self,inputfile='input.par',new_champ=False,bestoptfile='bestopt.par',
        potnames = {'1':'O1','2':'O2'},arc2kpc=1):
        f = open(inputfile,'r')
        lines = f.readlines()
        f.close()

        for i in range(len(lines)):
            ls = lines[i].rsplit()
            if len(ls) == 0: continue
            if ls[0] == 'H0':
                H0 = float(ls[1])
            if ls[0] == 'omegaM':
                omM = float(ls[1])
            if ls[0] == 'omegaX':
                omL = float(ls[1])
            if ls[0] == 'z_lens':
                zlens = float(ls[1])

        freeParams = np.zeros((2,len(self.parameters))).astype('str')
        for i in range(len(self.parameters)):
            parsep = self.parameters[i].rsplit()
            if len(parsep) < 2: continue
            if parsep[2] == "x": variable = "x_centre"
            if parsep[2] == "y": variable = "y_centre"
            if parsep[2] == "emass": variable = "ellipticite"
            if parsep[2] == "theta": variable = "angle_pos"
            if parsep[2] == "rc": variable = "core_radius"
            if parsep[2] == "sigma": variable = "v_disp"
            if parsep[2] == "rcut": variable = "cut_radius"
            if parsep[0] == "Redshift": variable = " ".join(parsep[2:])
            freeParams[0,i] = parsep[0]
            freeParams[1,i] = variable

        m = self.bestmodel
        f = open(bestoptfile,'w')

        i=0
        while i < len(lines):
            ls = lines[i].rsplit()
            if len(ls) == 0:
                i+=1
                continue
            if ls[0] == 'runmode':
                while ls[0] != 'end':
                    f.write(lines[i])
                    i+=1
                    ls = lines[i].rsplit()
                f.write(lines[i])

            ## parts of the file that can be directly copied
            if ls[0] == 'grille':
                while ls[0] != 'end':
                    f.write(lines[i])
                    i+=1
                    ls = lines[i].rsplit()
                f.write(lines[i])
            if ls[0] == 'source':
                while ls[0] != 'end':
                    f.write(lines[i])
                    i+=1
                    ls = lines[i].rsplit()
                f.write(lines[i])
            if ls[0] == 'image':
                while ls[0] != 'end':
                    f.write(lines[i])
                    i+=1
                    ls = lines[i].rsplit()
                f.write(lines[i])
            if ls[0] == 'cosmologie':
                while ls[0] != 'end':
                    f.write(lines[i])
                    i+=1
                    ls = lines[i].rsplit()
                f.write(lines[i])
            if ls[0] == 'potfile':
                while ls[0] != 'end':
                    f.write(lines[i])
                    i+=1
                    ls = lines[i].rsplit()
                f.write(lines[i])
            if ls[0] == 'champ':
                f.write(lines[i])
                i+=1
                ls = lines[i].rsplit()
                if not new_champ:
                    while ls[0] != 'end':
                        f.write(lines[i])
                        i+=1
                        ls = lines[i].rsplit()
                    f.write(lines[i])
                else:
                    while ls[0] != 'end':
                        i+=1
                        ls = lines[i].rsplit()
                    f.write('    xmin    {0:0.3f}\n'.format(new_champ[0]))
                    f.write('    xmax    {0:0.3f}\n'.format(new_champ[1]))
                    f.write('    ymin    {0:0.3f}\n'.format(new_champ[2]))
                    f.write('    ymax    {0:0.3f}\n'.format(new_champ[3]))
                    f.write(lines[i])
            if ls[0] == 'fini':
                f.write(lines[i])
            

            ### add free parameters to the potential blocks
            if ls[0] == 'potentiel':
                potname = potnames[ls[1]]
                f.write('potentiel '+potname+'\n')
                while ls[0] != 'end':
                    i+=1
                    ls = lines[i].rsplit()
                    paramtype = ls[0]
                    if paramtype == "cut_radius_kpc":
                        paramgrab = "cut_radius"
                        factor = arc2kpc
                    elif paramtype == "core_radius_kpc":
                        paramgrab = "core_radius"
                        factor = arc2kpc
                    else:
                        paramgrab = paramtype
                        factor = 1
                    if paramtype == 'mag': continue
                    paramIndex = np.all([freeParams[0,:] == potname,freeParams[1,:] == paramgrab],axis=0)
                    if np.sum(paramIndex) == 1:
                        model = self.models[m,:].flatten()
                        if arc2kpc == 1:
                            f.write('    {0}    {1:0.3f}\n'.format(paramgrab,model[paramIndex][0]))
                        else:
                            f.write('    {0}    {1:0.3f}\n'.format(paramtype,model[paramIndex][0]*factor))
                    else:
                        f.write(lines[i])
            if ls[0] == 'limit':
                potname = potnames[ls[1]]
                f.write('limit '+potname+'\n')
                i+=1
                while ls[0] != 'end':
                    f.write(lines[i])
                    i+=1
                    ls = lines[i].rsplit()
                f.write(lines[i])
            
            i+=1

        f.close()

            